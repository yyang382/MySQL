#CS 4400 Library Management System Group17from tkinter import *import urllib.requestimport pymysqlclass LMS:       def __init__(self):        #Connect to databse        self.db= pymysql.connect(host="academic-mysql.cc.gatech.edu",                                user="cs4400_Group_17",                                db="cs4400_Group_17",passwd = "t3YC9ti8")        self.c=self.db.cursor()             self.LoggingIn()    def LoggingIn(self):     #Creeat Log In Screen            #set up login window        win1 = Tk()        self.win1 = win1                win1.title("Login")        self.Username = StringVar()##        self.Username.set("")        Label(win1, text = '            Username: ').grid(row = 3, column = 2,sticky=E,pady=5 )        Entry(win1, width = 20, textvariable = self.Username).grid(row = 3, column = 3, sticky = W,pady=5 )        self.Password = StringVar()##        self.Password.set("")        Label(win1, text = '            Password: ').grid(row = 4, column = 2,sticky=E,pady=5 )        Entry(win1, width = 20, textvariable = self.Password).grid(row = 4, column = 3, sticky = W,pady=5 )        Button(win1, text = 'Login', width = 10, command=self.checkLogin).grid(row = 6, column = 4 ,pady=25)        Button(win1, text = 'Create Account', bg='blue', relief=FLAT ,command=self.newUserR).grid(row = 6, column = 6,padx=25 )    def updateDataBase(self):        #get all DISTINCT isbn                 checkAllHold = "SELECT DISTINCT ISBN FROM BOOK_COPY"        self.c.execute(checkAllHold)        allHold = self.c.fetchall()        #print(allHold)        for eachISBN in allHold:##            print(eachISBN)##            #get the copy number and isbn for each isbn            dropSQL="""SELECT ISBN,Copy_Number                        FROM BOOK_COPY                         WHERE ISBN=%s  AND Is_on_hold=1 AND Is_checked_out=0"""            dropR=self.c.execute(dropSQL,(eachISBN[0],))            #print(dropR)##            if dropR>0:  #If for this isbn, >=1copy is on hold                onHoldBTuples=self.c.fetchall()                #print(onHoldBTuples)##                for eachBTuple in onHoldBTuples:                    #print(eachBTuple )##                    #get infomation of the issue that is currently holding the book                    dropSQL="""SELECT Issue_ID, DATEDIFF(MAX(Date_of_issue),CURDATE()),MAX(Date_of_issue)                          FROM BOOK_COPY  NATURAL JOIN ISSUE                        WHERE ISBN=%s  AND  Copy_Number=%s                       GROUP BY Copy_Number"""                    self.c.execute(dropSQL,(eachBTuple[0],eachBTuple[1]))                    issueTuple=self.c.fetchone()                    #print(issueTuple)##                    dropIssueId = issueTuple[0]                    dropDateDiff = issueTuple[1]                    if dropDateDiff < -3 : #drop the hold and update the estimate return date if hold more than 3 days                       #print(dropDateDiff)                        updateBookSQL = "UPDATE BOOK_COPY SET Is_on_hold = %s, Future_requester=%s WHERE ISBN = %s AND Copy_Number = %s"                        self.c.execute(updateBookSQL,(0,None,eachBTuple[0],eachBTuple[1]))                        updateIssueSQL = "UPDATE ISSUE SET Return_Date = %s WHERE Issue_ID = %s"                        self.c.execute(updateIssueSQL,("0000-00-00",dropIssueId))                        self.db.commit()    def checkLogin(self):        self.currentUser=self.Username.get()        sql="SELECT COUNT(*) FROM USER WHERE Username='{}' AND Password='{}'".format(self.Username.get(),self.Password.get())        self.c.execute(sql)        numOfUser=self.c.fetchone()[0]        if numOfUser==1:                ###check log in infomation here            self.updateDataBase()            messagebox.askokcancel("Login Successful","Login Successful!")            self.win1.withdraw()            self.homePage()        else:            self.Password.set("")            messagebox.askokcancel("Login Failure","The Username or Password is incorrect.")                def newUserR(self):    #New User Registration        #set up create account window        self.win1.withdraw()        win2=Toplevel()        self.win2=win2        win2.title("New User Registration")        self.newName = StringVar()        Label(win2, text = '            Username: ').grid(row = 3, column = 2,sticky=E,pady=5 )        Entry(win2, width = 20, textvariable = self.newName ).grid(row = 3, column = 3, sticky = W,pady=5 )        self.newPassword = StringVar()        Label(win2, text = '            Password: ').grid(row = 4, column = 2,sticky=E,pady=5 )        Entry(win2, width = 20, textvariable = self.newPassword).grid(row = 4, column = 3, sticky = W,pady=5 )        self.newPwConfirm = StringVar()        Label(win2, text = '            Password: ').grid(row = 5, column = 2,sticky=E,pady=5 )        Entry(win2, width = 20, textvariable = self.newPwConfirm).grid(row = 5, column = 3, sticky = W,pady=5 )        Button(win2, text = 'Register', width = 10, command=self.checkNewUserR).grid(row = 6, column = 4 ,pady=25,padx=25)        Button(win2, text = 'Back', width = 10, command=self.BackcheckNewUserR).grid(row = 6, column = 5 ,pady=25,padx=25)    def BackcheckNewUserR(self):        self.win2.withdraw()        self.win1.deiconify()            def checkNewUserR(self):        newUN=self.newName.get()            #check new user registration information        newPW=self.newPassword.get()            newCPW=self.newPwConfirm.get()        self.newUN=newUN        self.newPW=newPW        conditionA=(newPW==newCPW)        conditionB= (newPW.strip() != "")        conditionC= (newUN.strip() != "")        if not conditionA:            messagebox.showwarning("Error","The passwords are not the same!")            return None        if not conditionB:            messagebox.showwarning("Error","The password cannot be empty")            return None        if not conditionC:            messagebox.showwarning("Error","The username cannot be empty")            return None        #Check whether the user name exists already        selectSQL="SELECT * FROM USER WHERE USERNAME='{}'".format(newUN)        sameUser=self.c.execute(selectSQL)        if sameUser>0:            messagebox.showwarning("Error","Username already exists")            return None        self.win2.withdraw()        self.createProfile()        ##SQL Insertion to USER will be executed under self.createProfile                                    ##To avoid creating an account without filling the profile.            def createProfile(self):        #Create Profile        #sest up create profile window        bWin=Toplevel()        self.bWin=bWin        bWin.title("Create Profile")        Label(bWin,text="First Name").grid(row=0,column=0,sticky=W,padx=25,pady=5)        Label(bWin,text="D.O.B(YYYY-MM--DD)").grid(row=1,column=0,sticky=W,padx=25,pady=5)        Label(bWin,text="Email").grid(row=2,column=0,sticky=W,padx=25,pady=5)        Label(bWin,text="Address").grid(row=3,column=0,sticky=W,padx=25,pady=5)        self.svfn=StringVar()        self.svdob=StringVar()        self.svemial=StringVar()        self.svaddress=StringVar()        Entry(bWin,width=30,textvariable=self.svfn).grid(row=0,column=1,padx=15,sticky=W)        Entry(bWin,width=15,textvariable=self.svdob).grid(row=1,column=1,sticky=W,padx=15)        Entry(bWin,width=30,textvariable=self.svemial).grid(row=2,column=1,sticky=W,padx=15)        Entry(bWin,width=30,textvariable=self.svaddress).grid(row=3,column=1,sticky=W,padx=15)        Label(bWin,text="Lastname").grid(row=0,column=2,sticky=W,pady=5)        Label(bWin,text="Gender").grid(row=1,column=2,sticky=W,pady=5)        Label(bWin,text="Are you faculty member?").grid(row=2,column=2,sticky=W,pady=5)        Label(bWin,text="Associated Department").grid(row=4,column=2,sticky=W,pady=5)        self.svln=StringVar()        self.genderVar=StringVar(bWin)        self.genderVar.set("NA")        self.facultyVar=IntVar()        self.facultyVar.set(0)           Entry(bWin,width=30,textvariable=self.svln).grid(row=0,column=3,sticky=W)        genderOM=OptionMenu(bWin,self.genderVar,"Female","Male", "NA")        genderOM.grid(row=1,column=3,sticky=W)        facultyRB=Radiobutton(bWin,text="Yes",variable=self.facultyVar,value=1)        facultyRB.grid(row=2,column=3,sticky=W)        Radiobutton(bWin,text="No",variable=self.facultyVar,value=0).grid(row=3,column=3,sticky=W)        self.departmentVar=StringVar(bWin)        self.departmentVar.set("NULL")        Button(bWin, text = 'Submit', width = 10, command=self.checkStudentFaculty).grid(row = 5, column = 3 ,pady=25)        Button(bWin, text = 'Back', width = 10, command=self.backFromCreateProfile).grid(row = 5, column = 4 ,pady=25)            def backFromCreateProfile(self):        self.bWin.withdraw()        self.win2.deiconify()    def checkStudentFaculty(self):##        print(self.facultyVar.get())####        print(self.departmentVar.get())        departmentNList=["NA","BME","ComputerScience","MATH","ElectricalEng",'IndustrialEng','ChemEng','AE','History','ChemEng']         if self.facultyVar.get()==0:                      self.checkCreateProfile()        elif self.facultyVar.get()==1 and self.departmentVar.get()=="NULL":            self.departmentVar.set("NA")            departmentOM=OptionMenu(self.bWin,self.departmentVar,*departmentNList)            departmentOM.grid(row=4,column=3,sticky=W)            messagebox.showwarning("","Please Enter your Department")        else:            self.checkCreateProfile()                    def checkCreateProfile(self):        #CHECK CreateProfile INFORMATION HERE                #Make sure the not null fields are filled in by user        if self.svfn.get().strip() == ""  or self.svln.get().strip() == "" or self.svdob.get()== "" or self.svemial.get().strip() == "" :                 messagebox.showwarning("Error","Missing Required Information")            return None        #Make sure birthday are enter in correct format        dobValue=self.svdob.get()        if dobValue[0:4].isdigit() and dobValue[4]=="-" and dobValue[5:7].isdigit() and dobValue[7]=="-" and dobValue[8:10].isdigit():            pass        else:            messagebox.showwarning("Error","DOB Fomat incorrect!")            return None        if self.genderVar.get()=="Female":            genderValue="F"        elif self.genderVar.get()=="Male":            genderValue="M"        else:            genderValue="N"        #Insert a row into USER table                USERSQL="INSERT INTO USER VALUES(%s,%s)"        self.c.execute(USERSQL,(self.newUN,self.newPW))        #Insert a row into the STUDENT_OR_FACULTY table         SorFSQL="INSERT INTO STUDENT_OR_FACULTY VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"        insertR=self.c.execute(SorFSQL,(self.newUN,self.svfn.get()+" "+self.svln.get(),self.svdob.get(),genderValue,                                   self.svemial.get(),self.svaddress.get(),0,self.facultyVar.get(),self.departmentVar.get(),0))        self.db.commit()        messagebox.askokcancel("Congratulations","Register Finished!")        self.bWin.withdraw()        self.win1.deiconify()            def homePage(self):     #Create Home Page After Login.                            #Include Button connection to search book, Requset extension, future hold, Track location,etc        homeWin=Toplevel()      #set up homepage        self.homeWin=homeWin        homeWin.title("Home Page")        Button(homeWin, text = 'Search Books',command=self.searchBook).grid(row = 1,pady=5, padx=25)        Button(homeWin, text = 'Request Extension on a book',command=self.requestExtension).grid(row = 2,pady=5, padx=25)        Button(homeWin, text = 'Future Hold Request for a Book',command=self.futureHold).grid(row = 3,pady=5,padx=25)        Button(homeWin, text = 'Track Book Location',command=self.trackLocation).grid(row = 4,pady=5,padx=25)##        Button(homeWin, text = 'Generate Reports', command = self.reportHome).grid(row = 7, pady = 5, padx = 25)        #check whether the user is a library staff        checkStaffSQL = "SELECT COUNT(*) FROM STAFF WHERE Username='{}'" .format(self.currentUser)        self.c.execute(checkStaffSQL)        isStaff=self.c.fetchone()[0]        if isStaff > 0 :            Button(homeWin, text = 'Return',command=self.returnBookScreen).grid(row = 6,pady=5,padx=25)            Button(homeWin, text = 'Checkout',command=self.checkoutScreen).grid(row = 5,pady=5,padx=25)            Button(homeWin, text = 'Generate Reports', command = self.reportHome).grid(row = 7, pady = 5, padx = 25)                def searchBook(self):       #Create Search Books Window        self.homeWin.withdraw()        sbWin=Toplevel()        self.sbWin = sbWin        sbWin.title("Search Books")        Label(sbWin, text = 'ISBN(Enter Numbers Only)').grid(row=0,column=0,sticky=W,padx =25,pady=5)        Label(sbWin,text='Title').grid(row=1,column=0,sticky=W,padx=25,pady=5)        Label(sbWin,text='Author(Enter One Author)').grid(row=2,column=0,sticky=W,padx=25,pady=5)        self.svISBN=StringVar()        self.svTitle=StringVar()        self.svAuthor=StringVar()        Entry(sbWin,width=30,textvariable=self.svISBN).grid(row=0,column=1,padx=15,sticky=W)        Entry(sbWin,width=30,textvariable=self.svTitle).grid(row=1,column=1,sticky=W,padx=15)        Entry(sbWin,width=30,textvariable=self.svAuthor).grid(row=2,column=1,sticky=W,padx=15)        Button(sbWin, text = 'Back', width = 10, command=self.backFromSearch).grid(row = 4, column = 1 ,pady=25)        Button(sbWin, text = 'Search', width = 10, command=self.doSearch).grid(row = 4, column = 2,padx=25 )        Button(sbWin, text = 'Close',  width = 10, command=self.closeSearch).grid(row = 4, column = 3,padx=25 )    def backFromSearch(self):# back to previous window        self.svISBN.set("")        self.svTitle.set("")        self.svAuthor.set("")    def doSearch(self): #Search Book here        isbnInput=self.svISBN.get().strip()        #The SQL to search for ISBN for each entry entered.        isbnSQL="SELECT ISBN FROM BOOK WHERE ISBN=%s"        titleSQL="SELECT ISBN FROM BOOK WHERE Title LIKE %s"        authorSQL="SELECT ISBN FROM BOOK NATURAL JOIN BOOK_AUTHORS WHERE Author LIKE %s"        if isbnInput != "":            searchR=self.c.execute(isbnSQL,(isbnInput))        elif self.svTitle.get().strip() != "":            searchR=self.c.execute(titleSQL,("%"+self.svTitle.get()+"%",))        elif self.svAuthor.get().strip() != "":            searchR=self.c.execute(authorSQL,("%"+self.svAuthor.get()+"%",))        else:            messagebox.askokcancel("","Please Enter At Least One Entry")            return None        if searchR==0:            messagebox.askokcancel("","No Book found.")            return None        isbnResult=[]        for row in self.c:            if row[0] not in isbnResult:                isbnResult.append(row[0])      #get a list of tuple        self.avaialbleList=[]             ##List of tuples        self.reservedList=[]        for tempISBN in isbnResult:          findAvailabelSQL="""SELECT ISBN, Title, Edition, COUNT(*),is_Reserved                         FROM BOOK NATURAL JOIN BOOK_COPY                         WHERE ISBN=%s AND Is_checked_out=%s AND Is_on_hold=%s AND Is_damaged=%s                        GROUP BY ISBN"""          findR=self.c.execute(findAvailabelSQL,(tempISBN,0,0,0))          if findR==1:              for aRow in self.c:                   if aRow[4]==0:                       self.avaialbleList.append(aRow[0:4])                   elif aRow[4]==1:                       self.reservedList.append(aRow[0:4])        if  len(self.reservedList)==0 and len(self.avaialbleList)==0:            messagebox.askokcancel("","The Books are not Available. The Books are Checked Out or Hold or Damaged.")        self.sbWin.withdraw()        self.holdRequest()    def closeSearch(self):                self.sbWin.withdraw()        self.homeWin.deiconify()    def holdRequest(self):      #Create Hold Request for Books Window##      Set-Up        hrWin=Toplevel()        self.hrWin = hrWin        hrWin.title("Hold Request for a Book")        self.searchResult=self.avaialbleList        self.rLength=len(self.searchResult)        self.searchReservResult=self.reservedList        self.rRLength=len(self.searchReservResult)##      Book Availabe Summary Part        Label(hrWin, text = 'Books Available Summary').grid(row=0,column=0,sticky=W)        self.bookAvailableSum()         #Create the table with all avaible books        Label(hrWin, text = 'Hold Request Date').grid(row = 2, column = 0)        Label(hrWin, text = 'Estimate Return Date').grid(row = 2, column = 3)        self.svHoldRequestDate=StringVar()        self.svEstimatedRet=StringVar()        Entry(hrWin, textvariable = self.svHoldRequestDate,state="readonly").grid(row = 2, column = 1)        Entry(hrWin, textvariable = self.svEstimatedRet,state="readonly").grid(row = 2, column = 4)        self.setDateInHoldRequest()        buttonFrame = Frame(hrWin)        buttonFrame.grid(row = 3, column = 2, columnspan = 3)        Button(buttonFrame, text = 'Back', command = self.backFromHoldRequst).grid(row = 0, column = 0, sticky = W)        Button(buttonFrame, text = 'Submit', command = self.submitHoldRequest).grid(row = 0, column = 1,sticky = W)        Button(buttonFrame, text = 'Close',command=self.closeHoldRequest).grid(row = 0, column = 2,sticky = W)##      Book on Reserve Part        labelFrame2 = Frame(hrWin)        labelFrame2.grid(row = 4, column = 0, sticky = W + E)        Label(labelFrame2, text = 'Reserved Books Summary').grid(row=0,column=0,sticky=W)        self.bookOnReserve()    def bookAvailableSum(self):        hrWin = self.hrWin                topTable = Frame(hrWin, bd = 6)        topTable.grid(row = 1, column = 0, sticky = W+N, columnspan = 5)                selectColumn = Frame(topTable,relief = RIDGE,bd = 2)        selectColumn.grid(row = 0, column = 0, ipadx = 10, sticky = W+E+N+S)        Label(selectColumn, text = 'Select').grid(row = 0, sticky = W+E)        ISBNColumn = Frame(topTable,relief = RIDGE,bd = 2)        ISBNColumn.grid(row = 0, column = 1, ipadx = 20, sticky = W+E+N+S)        Label(ISBNColumn, text = 'ISBN').grid(row = 0, sticky = W+E)        titleColumn = Frame(topTable,relief = RIDGE,bd = 2)        titleColumn.grid(row = 0, column = 2, ipadx = 80, sticky = W+E+N+S)        Label(titleColumn, text = 'Title of the Book').grid(row = 0, sticky = W+E)        editionColumn = Frame(topTable,relief = RIDGE,bd = 2)        editionColumn.grid(row = 0, column = 3, ipadx = 20, sticky = W+E+N+S)        Label(editionColumn, text = 'Edition').grid(row = 0, sticky = W+E)        copyColumn = Frame(topTable,relief = RIDGE,bd = 2)        copyColumn.grid(row = 0, column = 4, ipadx = 20, sticky = W+E+N+S)        Label(copyColumn, text = '#Copies Available').grid(row = 0, sticky = W+E)                self.intSelect=IntVar()        for rNum in range(self.rLength):                      Radiobutton(selectColumn,variable=self.intSelect,value=rNum).grid(row=rNum+1,column=0,sticky=W)            Label(ISBNColumn, text=self.searchResult[rNum][0]).grid(row=rNum+1,column=0,sticky=W+E,pady = 2)            Label(titleColumn, text=self.searchResult[rNum][1]).grid(row=rNum+1,column=0,sticky=W+E,pady = 2)            Label(editionColumn, text=str(self.searchResult[rNum][2])).grid(row=rNum+1,column=0,sticky=W+E,pady = 2)            Label(copyColumn, text=str(self.searchResult[rNum][3])).grid(row=rNum+1,column=0,sticky=W+E,pady = 2)    def setDateInHoldRequest(self):                self.c.execute("SELECT CURDATE()")              ##Fill in Date Entry        self.currentDate=self.c.fetchone()[0]        self.c.execute("SELECT DATE_ADD(CURDATE(),INTERVAL 17 DAY)")        self.estDate=self.c.fetchone()[0]        currentDate=self.currentDate        estDate=self.estDate##        print(currentDate)####        print(estDate)##        self.svHoldRequestDate.set(currentDate)        self.svEstimatedRet.set(estDate)    def bookOnReserve(self):        hrWin = self.hrWin                bottomTable = Frame(hrWin)        bottomTable.grid(row = 5, column = 0, sticky = W + E + N,columnspan = 5)            ISBNColumn = Frame(bottomTable,relief = RIDGE,bd = 2)        ISBNColumn.grid(row = 0, column = 0, sticky = W + N + S + E,ipadx = 30)        Label(ISBNColumn, text = 'ISBN').grid(row = 0, sticky = W + E)        titleColumn = Frame(bottomTable,relief = RIDGE,bd = 2)        titleColumn.grid(row = 0, column = 1, sticky = W + N + S + E,ipadx = 115)        Label(titleColumn, text = 'Title of the Book').grid(row = 0, sticky = W + E)        editionColumn = Frame(bottomTable,relief = RIDGE,bd = 2)        editionColumn.grid(row = 0, column = 2, sticky = W + N + S + E,ipadx = 20)        Label(editionColumn, text = 'Edition').grid(row = 0, sticky = W + E)        copyColumn = Frame(bottomTable,relief = RIDGE,bd = 2)        copyColumn.grid(row = 0, column = 3, sticky = W + N + S + E,ipadx = 20)        Label(copyColumn, text = '#Copies Available').grid(row = 0, sticky = W + E)        for rNum in range(self.rRLength):            Label(ISBNColumn, text=self.searchReservResult[rNum][0]).grid(row=rNum+1,column=0,sticky=W+E)            Label(titleColumn, text=self.searchReservResult[rNum][1]).grid(row=rNum+1,column=0,sticky=W+E)            Label(editionColumn, text=str(self.searchReservResult[rNum][2])).grid(row=rNum+1,column=0,sticky=W+E)            Label(copyColumn, text=str(self.searchReservResult[rNum][3])).grid(row=rNum+1,column=0,sticky=W+E)    def closeHoldRequest(self):        self.hrWin.withdraw()        self.homeWin.deiconify()                def backFromHoldRequst(self):        self.hrWin.withdraw()        self.sbWin.deiconify()        def submitHoldRequest(self):     # Record Hold Request Here        currentDate=self.currentDate        estDate=self.estDate        #get the isbn of the seleted book        selectedISBN=self.searchResult[self.intSelect.get()][0]        #get the min availble copy number of the selected isbn        minCNSQL="SELECT MIN(Copy_number) FROM BOOK_COPY WHERE ISBN=%s AND Is_checked_out=%s AND Is_on_hold=%s AND Is_damaged=%s"        self.c.execute(minCNSQL,(selectedISBN,0,0,0))        minCN=self.c.fetchone()[0]        #place the hold on BOOK_COPY Table        bookcopySQL="UPDATE BOOK_COPY SET Is_on_hold=%s WHERE ISBN=%s AND Copy_number=%s"        self.c.execute(bookcopySQL,(1,selectedISBN,minCN))        #get the current max issue id        issueIDSQL= "SELECT MAX(Issue_ID) FROM ISSUE"        self.c.execute(issueIDSQL)        newIssueID=self.c.fetchone()[0]+1        #insert a row in the issue table for the hold        issueSQL="INSERT INTO ISSUE VALUES(%s, %s, %s,%s,CURDATE(),CURDATE(),%s,0)"        self.c.execute(issueSQL,(self.currentUser,selectedISBN,minCN,newIssueID,estDate))                         self.db.commit()               self.hrWin.withdraw()        self.homeWin.deiconify()        messagebox.askokcancel("","Hold Request Sent!")                  def requestExtension(self):        self.homeWin.withdraw()        reWin = Toplevel()        self.reWin = reWin        reWin.title("Request extension on  a book")                self.reIssueId = StringVar()                Label(reWin, text = 'Enter you issue_id').grid(row=0,column=0,sticky=W,padx =25,pady=5)        Entry(reWin,width=30,textvariable=self.reIssueId).grid(row=0,column=1,sticky=W,padx=15)                Button(reWin, text = 'Search', width = 10, command=self.checkExtension).grid(row = 0, column = 2 ,pady=25)        Button(reWin, text = 'Back', width = 10, command=self.backFromExtension).grid(row = 0, column = 3 ,pady=25)    def backFromExtension(self):        self.reWin.withdraw()        self.homeWin.deiconify()                           def checkExtension(self):        try:            self.currentIID=int(self.reIssueId.get())                  except:            messagebox.askokcancel("Error","Invalid Issue ID!")            return None             #Make sure the ISSUE ID is valid        selectSQL="SELECT * FROM ISSUE WHERE Issue_ID=%s "        selectR=self.c.execute(selectSQL,(self.currentIID,))        if selectR==1 :            self.issueInfo=self.c.fetchone()            ##print(self.issueInfo)##            issueUN=self.issueInfo[0]            ##print(issueUN)##            if issueUN==self.currentUser:                holdOrCheckSQL="SELECT Is_checked_out FROM ISSUE NATURAL JOIN BOOK_COPY WHERE Issue_ID=%s "                self.c.execute(holdOrCheckSQL,(self.currentIID,))                status=self.c.fetchone()[0]                if status==1:                                        self.requestExtensionMore()                elif status==0:                    messagebox.askokcancel("Error","Not Avaible to Extension Hold")            else:                messagebox.askokcancel("Error","Invalid Issue ID!")                return None        else:            messagebox.askokcancel("Error","Invalid Issue ID!")            return None    def requestExtensionMore(self):                Label(self.reWin,text="Original Checkout Date").grid(row=2,column=0,sticky=W,pady=5)        Label(self.reWin,text="Current Extension Date").grid(row=3,column=0,sticky=W,pady=5)        Label(self.reWin,text="New Extension Date").grid(row=4,column=0,sticky=W,pady=5)        Label(self.reWin,text="Current Return Date").grid(row=3,column=2,sticky=W,pady=5)        Label(self.reWin,text="New Extimated Return Date").grid(row=4,column=2,sticky=W,pady=5)        self.OriCheckouteD = StringVar()        self.CurExtD = StringVar()        self.CurReturnD= StringVar()        self.NewExtD = StringVar()        self.NewEstReturnD = StringVar()        Entry(self.reWin,width=30,textvariable=self.OriCheckouteD,state="readonly").grid(row=2,column=1,sticky=W,pady=5)        Entry(self.reWin,width=30,textvariable=self.CurExtD,state="readonly").grid(row=3,column=1,sticky=W,pady=5)        Entry(self.reWin,width=30,textvariable=self.CurReturnD,state="readonly").grid(row=3,column=4,sticky=W,pady=5)        Entry(self.reWin,width=30,textvariable=self.NewExtD,state="readonly").grid(row=4,column=1,sticky=W,pady=5)        Entry(self.reWin,width=30,textvariable=self.NewEstReturnD,state="readonly").grid(row=4,column=4,sticky=W,pady=5)        #check whether the user is a faculty or a student        isFSQL="SELECT is_Faculty FROM STUDENT_OR_FACULTY WHERE Username=%s"     #Check faculty or student        self.c.execute(isFSQL,(self.issueInfo[0]))        isFaculty= self.c.fetchone()[0]        ##print(isFaculty)##        if isFaculty==0 and self.issueInfo[7]<2:            #Check Num of Extension            maxCheckoutLen=28            ##print(maxCheckoutLen)##        elif isFaculty==1 and self.issueInfo[7]<5:            maxCheckoutLen=56            ##print(maxCheckoutLen)##        else:            messagebox.askokcancel("Error","Exceed Maximum Number of Extension!")            return None        Button(self.reWin,text="Submit",width=10,command=self.submitExtension).grid(row=5,column=4 ,pady=25)        self.OriCheckouteD.set(self.issueInfo[4])        self.CurExtD.set(self.issueInfo[5])        self.CurReturnD.set(self.issueInfo[6])        self.c.execute("SELECT CURDATE()")              ##Fill in Date Entry        self.currentDate=self.c.fetchone()[0]        self.c.execute("SELECT DATE_ADD(CURDATE(),INTERVAL 14 DAY)")        self.estDate1=self.c.fetchone()[0]        self.c.execute("SELECT DATE_ADD(Date_of_issue,INTERVAL %s DAY) FROM ISSUE WHERE Issue_ID=%s ",(maxCheckoutLen,self.issueInfo[3]))        self.estDate2=self.c.fetchone()[0]        currentDate=self.currentDate        estDate1=self.estDate1        estDate2=self.estDate2        self.tureReturnDateSQL=min(estDate1,estDate2)        self.NewExtD.set(self.currentDate)        self.NewEstReturnD.set(self.tureReturnDateSQL)            def submitExtension(self):       #search for extension book here and show the information of the book.(use a new window)                        bookcopySQL="SELECT Future_requester FROM BOOK_COPY WHERE ISBN=%s AND Copy_Number=%s"   #Check whether has future request        self.c.execute(bookcopySQL,(self.issueInfo[1],self.issueInfo[2]))        fRequesterTuple=self.c.fetchone()[0]##        print(fRequesterTuple)##        if fRequesterTuple != None:            messagebox.askokcancel("","Currently Has Future Hold. NO Extension Allowed!")            self.reWin.withdraw()            self.homeWin.deiconify()            return None        #place the extension(update issue)        updateSQL="""UPDATE ISSUE SET Extension_date=CURDATE(), Return_Date=%s,                    Count_of_extension=%s  WHERE Issue_ID=%s"""        self.c.execute(updateSQL,(self.tureReturnDateSQL,self.issueInfo[7]+1,self.issueInfo[3]))        self.db.commit()        messagebox.askokcancel("","Extension Request Submitted")        self.reWin.withdraw()        self.homeWin.deiconify()        def futureHold(self):        self.homeWin.withdraw()        fhWin = Toplevel()        self.fhWin = fhWin        fhWin.title("Future Hold Request for a Book")        self.fhISBN = StringVar()                                        #get fnISBN by sql        Label(fhWin, text = 'ISBN').grid(row=0,column=0,sticky=W,padx =25,pady=5)        Entry(fhWin,width=30,textvariable=self.fhISBN).grid(row=0,column=1,sticky=W,padx=15)        Button(fhWin, text = 'Search', width = 10, command=self.reFutureHold).grid(row = 0, column = 2 ,pady=25)        Button(fhWin, text = 'Back', width = 10, command=self.backFromFutureHold).grid(row = 0, column = 3 ,pady=25)    def backFromFutureHold(self):        self.fhWin.withdraw()        self.homeWin.deiconify()            def reFutureHold(self):                self.currentISBN=self.fhISBN.get()                        bookSQL="SELECT is_Reserved FROM BOOK WHERE ISBN=%s"              bookR=self.c.execute(bookSQL,(self.currentISBN,))                if bookR==0:                    #check does the isbn valid            messagebox.askokcancel("","ISBN Does Not Exist")            return None                 isReserved= self.c.fetchone()[0]                #check is_Reserved=?        if isReserved==1:            messagebox.askokcancel("","This is a reseved book! No Future hold allowed")            return None         #get info about the book that will be available first        selectSQL=""" SELECT Copy_Number, MAX(Return_Date), Future_requester FROM BOOK_COPY NATURAL JOIN ISSUE                    WHERE ISBN=%s AND (Is_on_hold=1 OR Is_checked_out=1) AND Is_damaged=0 AND Return_Date>=CURDATE()                      GROUP BY Copy_Number ORDER BY Return_Date"""        selectR=self.c.execute(selectSQL,(self.currentISBN))        messageStr1="No Book Copy Available for Future Hold.\n"        messageStr2="Future Hold could only be placed on checked-out or on-hold books.\n"        messageStr3="The book you searching macy be avaivale now, please use search to check availability."        if selectR==0:            messagebox.askokcancel("",messageStr1+messageStr2+messageStr3)                        return None        self.firstAvailableBookT=self.c.fetchall()##        choosenFBookInfo=None        for aTuple in self.firstAvailableBookT:            if aTuple[2] != None:                pass            else:                choosenFBookInfo=aTuple[0:2]                break        if choosenFBookInfo==None:            messagebox.askokcancel("","All checked out or on hold copies of the book are future hold by someone else.")            messagebox.askokcancel("",messageStr2+messageStr3)             return None                            Label(self.fhWin,text="Copy Number").grid(row=2,column=0,sticky=W,pady=5)        Label(self.fhWin,text="Expected Available Date").grid(row=3,column=0,sticky=W,pady=5)        self.copyNum=StringVar()        self.ExpAvailableDate=StringVar()        Entry(self.fhWin,width=30,textvariable=self.copyNum,state="readonly").grid(row=2,column=1,sticky=W,pady=5)        Entry(self.fhWin,width=30,textvariable=self.ExpAvailableDate,state="readonly").grid(row=3,column=1,sticky=W,pady=5)        Button(self.fhWin, text = 'OK', width = 10, command=self.reFutureHoldOk).grid(row = 5, column = 3 ,pady=25)        self.copyNum.set(choosenFBookInfo[0])        self.ExpAvailableDate.set(choosenFBookInfo[1])        self.choosenFBookInfo=choosenFBookInfo                   def reFutureHoldOk(self): #update database of reture holder        #insert a future requester to book copy table        bcSQL="UPDATE BOOK_COPY SET Future_requester=%s WHERE ISBN=%s AND Copy_Number=%s"        self.c.execute(bcSQL,(self.currentUser,self.currentISBN,self.choosenFBookInfo[0]))        messagebox.askokcancel("","Future Hold Request Sent")                self.db.commit()        self.fhWin.withdraw()        self.homeWin.deiconify()                        def trackLocation(self):                tlWin = Toplevel()        self.tlWin = tlWin        self.homeWin.withdraw()        self.tlISBN = StringVar();        Label(tlWin, text = 'ISBN').grid(row=0,column=0,sticky=W,padx =25,pady=5)        Entry(tlWin,width=30,textvariable=self.tlISBN).grid(row=0,column=1,sticky=W,padx=15)        Button(tlWin, text = 'Locate', width = 10, command=self.locateBook).grid(row = 0, column = 2 ,pady=25)        Button(tlWin, text = 'Close', width = 10, command=self.closeLocateBook).grid(row = 0, column = 3 ,pady=25)    def closeLocateBook(self):        self.tlWin.withdraw()        self.homeWin.deiconify()            def locateBook(self):        #get the location infomation of the book        locateSQL="SELECT Floor_number, Shelf_number,Aisle_number, Sub_name FROM BOOK NATURAL JOIN SHELF WHERE ISBN=%s"        locateR=self.c.execute(locateSQL,(self.tlISBN.get()))        if locateR==0:            messagebox.askokcancel("Invalid ISBN","Invalid ISBN")            return        locateInfoT=self.c.fetchone()        Label(self.tlWin,text="Floor Number").grid(row=3,column=0,sticky=W,pady=5)        Label(self.tlWin,text="Aisle Number").grid(row=4,column=0,sticky=W,pady=5)        Label(self.tlWin,text="Shelf Number").grid(row=3,column=2,sticky=W,pady=5)        Label(self.tlWin,text="Subject").grid(row=4,column=2,sticky=W,pady=5)        self.svFloorNum=StringVar()        self.svShelfNum=StringVar()        self.svAisleNum=StringVar()        self.svSubject=StringVar()        self.svFloorNum.set(str(locateInfoT[0]))        self.svShelfNum.set(str(locateInfoT[1]))        self.svAisleNum.set(str(locateInfoT[2]))        self.svSubject.set(locateInfoT[3])        Entry(self.tlWin,width=30,textvariable=self.svFloorNum,state="readonly").grid(row=3,column=1,sticky=W,pady=5)        Entry(self.tlWin,width=30,textvariable=self.svShelfNum,state="readonly").grid(row=3,column=3,sticky=W,pady=5)        Entry(self.tlWin,width=30,textvariable=self.svAisleNum,state="readonly").grid(row=4,column=1,sticky=W,pady=5)        Entry(self.tlWin,width=30,textvariable=self.svSubject,state="readonly").grid(row=4,column=3,sticky=W,pady=5)                Button(self.tlWin, text = 'OK', width = 10, command=self.trackOK).grid(row = 5, column = 3 ,pady=25)    def trackOK(self):            self.tlWin.withdraw()        self.homeWin.deiconify()##########Yang's code starts here    def checkoutScreen(self):        csWin=Toplevel()        self.csWin = csWin        csWin.title("Book Checkout")        Label(csWin, text = 'Issue Id').grid(row=0,column=0,sticky=W,padx=25,pady=5)        Label(csWin,text='User Name').grid(row=0,column=2,sticky=W,padx=25,pady=5)        Label(csWin, text = 'ISBN').grid(row=1,column=0,sticky=W,padx =25,pady=5)        Label(csWin,text='Copy#').grid(row=1,column=2,sticky=W,padx=25,pady=5)        Label(csWin,text='Check out Date').grid(row=2,column=0,sticky=W,padx=25,pady=5)        Label(csWin,text='Estimated Return Date').grid(row=2,column=2,sticky=W,padx=25,pady=5)                       #scan book and user card to get book information and user information        # if user has hold, close window and give warning                self.checkID = IntVar()        Entry(csWin, width = 30, textvariable=self.checkID).grid(row=0,column=1,sticky=W,padx=25,pady=5)        Button(csWin, text = 'Confirm',  width = 10, command=self.confirmCheckout).grid(row = 4, column = 1,padx=25 )                 Button(csWin,text='SubmitIssue_Id',width=10,command=self.getCheckInfo).grid(row=4,column = 0, padx=25)        Button(csWin,text='Back',width=10,command=self.backFromCheck).grid(row=4,column = 2,padx=25)    def getCheckInfo(self):        self.checkIssueId = self.checkID.get()        sql="SELECT COUNT(*) FROM ISSUE WHERE Issue_ID={}".format(self.checkIssueId)        self.c.execute(sql)        numOfId=self.c.fetchone()[0]        if numOfId==0:                            messagebox.askokcancel("","Please enter right IssueID")        else:            self.checkUsername = StringVar()            self.checkISBN = StringVar()            self.checkCopyNo = StringVar()            self.checkOutDate = StringVar()            self.checkOutEstDate = StringVar()                        Entry(self.csWin, width = 30, textvariable=self.checkUsername,state = "readonly").grid(row=0,column=3,sticky=W,padx=25,pady=5)            Entry(self.csWin, width = 30, textvariable=self.checkISBN,state = "readonly").grid(row=1,column=1,sticky=W,padx=25,pady=5)            Entry(self.csWin, width = 30, textvariable=self.checkCopyNo,state = "readonly").grid(row=1,column=3,sticky=W,padx=25,pady=5)            Entry(self.csWin, width = 30, textvariable=self.checkOutDate,state = "readonly").grid(row=2,column=1,sticky=W,padx=25,pady=5)            Entry(self.csWin, width = 30, textvariable=self.checkOutEstDate,state = "readonly").grid(row=2,column=3,sticky=W,padx=25,pady=5)            UsernameSQL = "SELECT Username FROM ISSUE WHERE Issue_ID = {}".format(self.checkIssueId)            self.c.execute(UsernameSQL)            self.checkUsername.set(self.c.fetchone()[0])            ISBNSQL = "SELECT ISBN FROM ISSUE WHERE Issue_ID = {}".format(self.checkIssueId)            self.c.execute(ISBNSQL)            self.checkISBN.set(self.c.fetchone()[0])            CopyNoSQL = "SELECT Copy_Number FROM ISSUE WHERE Issue_ID = {}".format(self.checkIssueId)            self.c.execute(CopyNoSQL)            self.checkCopyNo.set(self.c.fetchone()[0])                        self.c.execute("SELECT CURDATE()")              ##Fill in Date Entry            currentDate=self.c.fetchone()[0]            currentDate = self.c.fetchone()[0]            self.checkOutDate.set(currentDate)            self.checkOutDate = self.checkOutDate.get()                        self.c.execute("SELECT DATE_ADD(CURDATE(),INTERVAL 14 DAY)")            estDate=self.c.fetchone()[0]            self.checkOutEstDate.set(estDate)            self.checkOutEstDate = self.checkOutEstDate.get()            self.checkISBN = self.checkISBN.get()            self.checkCopyNo =self.checkCopyNo.get()        #incase double check out            returnDateSQL = "SELECT Return_Date FROM ISSUE WHERE Issue_ID = {}".format(self.checkIssueId)            self.c.execute(returnDateSQL)            returnDate = self.c.fetchone()[0]            isCheckoutSQL = "SELECT Is_checked_out FROM BOOK_COPY WHERE ISBN = %s AND Copy_Number = %s"            self.c.execute(isCheckoutSQL,(self.checkISBN,self.checkCopyNo))            isCheckout = self.c.fetchone()[0]            isOnholdSQL = "SELECT Is_on_hold FROM BOOK_COPY WHERE ISBN = %s AND Copy_Number = %s"            self.c.execute(isOnholdSQL,(self.checkISBN,self.checkCopyNo))            isOnhold = self.c.fetchone()[0]                        issueDateSQL = "SELECT Date_of_issue FROM ISSUE WHERE Issue_ID = {}".format(self.checkIssueId)            self.c.execute(issueDateSQL)            self.checkIssueDate = self.c.fetchone()[0]                                       if returnDate == None:                if isCheckout == 1 or isOnhold == 1:                    leftCopySQL = "SELECT COUNT(*) FROM BOOK_COPY WHERE ISBN = '{}' AND Is_damaged = FALSE AND is_on_hold = FALSE AND is_checked_out = FALSE".format(self.checkISBN)                    self.c.execute(leftCopySQL)                    leftCopy = self.c.fetchone()[0]                    if leftCopy > 0 :                        messagebox.askokcancel("","Your hold has been dropped,But there are other copies left,You can locate that and make a request now""")                        self.csWin.withdraw()                        self.trackLocation()                    else :                        messagebox.askokcancel("","Your hold has been dropped,No copies left, please make a future request")                        self.csWin.withdraw()                        self.futureHold()                else:                    messagebox.askokcancel("","Your hold has been dropped,But there are other copies left,You can locate that and make a request now""")                    self.csWin.withdraw()                    self.trackLocation()                return            else:                if returnDate  <= currentDate:                    messagebox.askokcancel("","You may have already finished this issue or come to pick up too late, please make a new request")                    self.csWin.withdraw()                    self.homeWin.deiconify()                return                                               #compare info            if (returnDate - self.checkIssueDate).days == 14:                messagebox.askokcancel("","You have already checked out this book")                self.csWin.withdraw()                self.homeWin.deiconify()                return                                             def confirmCheckout(self):        confirmCheckSQL = "UPDATE ISSUE SET Date_of_issue = %s,Extension_date=%s ,Return_Date = %s WHERE ISBN=%s AND Copy_Number=%s"        self.c.execute(confirmCheckSQL,(self.checkOutDate,self.checkOutDate,self.checkOutEstDate,self.checkISBN, self.checkCopyNo))        updateBookSQL = "UPDATE BOOK_COPY SET Is_on_hold = %s, Is_checked_out = %s WHERE ISBN = %s AND Copy_Number = %s"        self.c.execute(updateBookSQL,(0,1,self.checkISBN,self.checkCopyNo))        self.db.commit()        messagebox.askokcancel("","Checkout confirmed")        self.backFromCheck()    def backFromCheck(self):        self.csWin.withdraw()        self.homeWin.deiconify()    def returnBookScreen(self):        rbWin=Toplevel()        self.rbWin = rbWin        rbWin.title("Return Book")                Label(rbWin, text = 'Issue_Id').grid(row=0,column=0,sticky=W,padx =25,pady=5)        #get isbn, copy number, username from scan        self.returnID = IntVar()        Entry(rbWin, width = 30, textvariable=self.returnID).grid(row=0,column=1,sticky=W,padx=25,pady=5)        Button(rbWin, text = 'SubmitIssueId',  width = 15, command=self.returnInfo).grid(row = 4, column = 1,padx=25 )        def returnInfo(self):        Label(self.rbWin, text = 'ISBN').grid(row=1,column=0,sticky=W,padx =25,pady=5)        Label(self.rbWin,text='Copy#').grid(row=1,column=2,sticky=W,padx=25,pady=5)        Label(self.rbWin,text='Return in Damaged Condition').grid(row=2,column=0,sticky=W,padx=25,pady=5)        Label(self.rbWin,text='User Name').grid(row=2,column=2,sticky=W,padx=25,pady=5)        self.returnIssueId = self.returnID.get()        sql="SELECT COUNT(*) FROM ISSUE WHERE Issue_ID={}".format(self.returnIssueId)        self.c.execute(sql)        numOfId = self.c.fetchone()[0] #       print(numOfId)        if numOfId==0:                            messagebox.askokcancel("","Please enter right IssueID")        else:            self.returnISBN = StringVar()            self.returnCopyNo = StringVar()            self.returnUsername = StringVar()                        Entry(self.rbWin, width = 30, textvariable=self.returnISBN,state = "readonly").grid(row=1,column=1,sticky=W,padx=25,pady=5)            Entry(self.rbWin, width = 30, textvariable=self.returnCopyNo,state = "readonly").grid(row=1,column=3,sticky=W,padx=25,pady=5)            Entry(self.rbWin, width = 30, textvariable=self.returnUsername,state = "readonly").grid(row=2,column=3,sticky=W,padx=25,pady=5)            ISBNSQL = "SELECT ISBN FROM ISSUE WHERE Issue_ID = {}".format(self.returnIssueId)            self.c.execute(ISBNSQL)            self.returnISBN.set(self.c.fetchone()[0])            self.returnISBN = self.returnISBN.get()                        CopyNoSQL = "SELECT Copy_Number FROM ISSUE WHERE Issue_ID = {}".format(self.returnIssueId)            self.c.execute(CopyNoSQL)            self.returnCopyNo.set(self.c.fetchone()[0])            self.returnCopyNo = self.returnCopyNo.get()                        UsernameSQL = "SELECT Username FROM ISSUE WHERE Issue_ID = {}".format(self.returnIssueId)            self.c.execute(UsernameSQL)            self.returnUsername.set(self.c.fetchone()[0])            self.returnUsername = self.returnUsername.get()                        Button(self.rbWin, text = 'Confirm',  width = 10, command=self.checkDamage).grid(row = 4, column = 3,padx=25 )            self.returnLb=Listbox(self.rbWin)            for item in ['N','Y']:                    self.returnLb.insert(END,item)            self.returnLb.selection_set(0)            self.returnLb.grid(row=2,column=1,sticky=W,padx=25,pady=5)            #check return date            self.c.execute("SELECT CURDATE()")              ##Fill in Date Entry            currentDate=self.c.fetchone()[0]            self.actualReturnDate = self.c.fetchone()[0]            estdateSQL = "SELECT Return_Date FROM ISSUE WHERE Issue_ID = {}".format(self.returnIssueId)            self.c.execute(estdateSQL)            self.estReturnDate = self.c.fetchone()[0]                        datediff = (self.actualReturnDate - self.estReturnDate).days            #print(datediff)            if datediff > 0 :                messagebox.askokcancel("","Late return")                getPenaltySQL = "SELECT Penalty FROM STUDENT_OR_FACULTY WHERE Username = %s"                self.c.execute(getPenaltySQL,self.returnUsername)                penalty = float(self.c.fetchone()[0])                               latePenalty = penalty + datediff*0.5                updatePenaltySQL = "UPDATE STUDENT_OR_FACULTY SET Penalty = %s WHERE Username = %s"                self.c.execute(updatePenaltySQL,(latePenalty,self.returnUsername))                if latePenalty >= 100 :                    debarUserSQL = "UPDATE STUDENT_OR_FACULTY SET is_Debarred = %s WHERE Username = %s"                    self.c.execute(debarUserSQL,(1,self.returnUsername))                self.db.commit()    def checkDamage(self):        damageSelection = self.returnLb.get(self.returnLb.curselection()[0])        #print(damageSelection)        if damageSelection== 'Y':            self.lostDamageScreen()        else:            self.returnBook()##########    def returnBook(self):        returnupdateSQL = "UPDATE BOOK_COPY SET IS_Checked_Out =  %s WHERE ISBN = %s AND Copy_Number = %s"        self.c.execute(returnupdateSQL,(0,self.returnISBN,self.returnCopyNo))        returnIssueSQL = "UPDATE ISSUE SET Return_Date = %s WHERE Issue_ID = %s"        self.c.execute(returnIssueSQL,(self.actualReturnDate, self.returnIssueId))                messagebox.askokcancel("","Successfully returned")        futureRequestSQL = "SELECT Future_requester FROM BOOK_COPY WHERE ISBN = %s AND Copy_Number = %s"        self.c.execute(futureRequestSQL,(self.returnISBN,self.returnCopyNo))        returnFuture = self.c.fetchone()[0]        if returnFuture != None:            updateFutureSQL = "UPDATE BOOK_COPY SET Future_requester = %s WHERE ISBN = %s AND Copy_Number = %s"            self.c.execute(updateFutureSQL,(None,self.returnISBN,self.returnCopyNo))        self.db.commit()        self.rbWin.withdraw()        self.homeWin.deiconify()##########    from datetime import datetime    def lostDamageScreen(self):        self.rbWin.withdraw()        ldWin=Toplevel()        self.ldWin = ldWin        ldWin.title("Lost/Damaged Book")         Label(ldWin, text = 'ISBN').grid(row=0,column=0,sticky=W,padx =25,pady=5)        Label(ldWin,text='Copy#').grid(row=0,column=2,sticky=W,padx=25,pady=5)        Label(ldWin,text='Current Time').grid(row=1,column=0,sticky=W,padx=25,pady=5)        self.damageReturnISBN = StringVar()        self.damageReturnCopyNo = StringVar()        Entry(ldWin, width = 30, textvariable=self.damageReturnISBN,state = "readonly").grid(row=0,column=1,sticky=W,padx=25,pady=5)        Entry(ldWin, width = 30, textvariable=self.damageReturnCopyNo,state = "readonly").grid(row=0,column=3,sticky=W,padx=25,pady=5)        self.damageReturnISBN.set(self.returnISBN)        self.damageReturnCopyNo.set(self.returnCopyNo)        self.damageReturnISBN = self.damageReturnISBN.get()        self.damageReturnCopyNo = self.damageReturnCopyNo.get()                currentTime = StringVar()        Entry(ldWin, width = 30, textvariable=currentTime,state = "readonly").grid(row=1,column=1,sticky=W,padx=25,pady=5)        self.c.execute("SELECT CURDATE()")              ##Fill in Date Entry        currentTime.set(self.c.fetchone()[0])                #get last user        Button(ldWin, text = 'get last user',  width = 10, command=self.lastUser).grid(row = 2, column = 3,padx=25 )                def lastUser(self):        Label(self.ldWin,text='Last User of the Book').grid(row=5,column=0,sticky=W,padx=25,pady=5)        Label(self.ldWin,text='Amount to be charged').grid(row=7,column=0,sticky=W,padx=25,pady=5)        Label(self.ldWin,text ='Book price').grid(row=6,column=0,sticky=W,padx=25,pady=5)        self.damageLastUser = StringVar()        Entry(self.ldWin, width = 30, textvariable=self.damageLastUser,state = "readonly").grid(row=5,column=1,sticky=W,padx=25,pady=5)        self.damageLastUser.set(self.returnUsername)        self.damageLastUser = self.damageLastUser.get()        self.bookCost = StringVar()        Entry(self.ldWin, width = 30, textvariable=self.bookCost,state = "readonly").grid(row=6,column=1,sticky=W,padx=25,pady=5)                         bookCostSQL = "SELECT Cost FROM BOOK WHERE ISBN = %s"        self.c.execute(bookCostSQL,self.damageReturnISBN)        self.bookCost.set(self.c.fetchone()[0])                        self.charged = StringVar()        Entry(self.ldWin, width = 30, textvariable=self.charged,state = "readonly").grid(row=7,column=1,sticky=W,padx=25,pady=5)               priceSQL = "SELECT Cost FROM BOOK WHERE ISBN = {}".format(self.damageReturnISBN)        self.c.execute(priceSQL)                self.charged.set(self.c.fetchone()[0] * 0.5)                Button(self.ldWin, text = 'Submit',  width = 10, command=self.SubmitPenalty).grid(row = 8, column = 1,padx=25 )        Button(self.ldWin, text = 'Cancel',  width = 10, command=self.CancelPenalty).grid(row = 8, column = 2,padx=25 )    def SubmitPenalty(self):        reportDamageSQL = "UPDATE BOOK_COPY SET Is_Damaged = %s WHERE ISBN = %s AND Copy_Number = %s"        self.c.execute(reportDamageSQL,(1,self.damageReturnISBN,self.damageReturnCopyNo))        self.penalty = float(self.charged.get())        getPenaltySQL = "SELECT Penalty FROM STUDENT_OR_FACULTY WHERE Username = %s"        self.c.execute(getPenaltySQL,self.damageLastUser)        self.originalPenalty = float(self.c.fetchone()[0])                       self.newPenalty = self.originalPenalty + self.penalty        updatePenaltySQL = "UPDATE STUDENT_OR_FACULTY SET Penalty = %s WHERE Username = %s"        self.c.execute(updatePenaltySQL,(self.newPenalty,self.damageLastUser))##############        if self.newPenalty >= 100 :              debarUserSQL = "UPDATE STUDENT_OR_FACULTY SET is_Debarred = %s WHERE Username = %s"              self.c.execute(debarUserSQL,(1,self.damageLastUser))        self.db.commit()        messagebox.askokcancel("","Penalty reported")        Button(self.ldWin, text = 'Return',  width = 10, command=self.returnBook).grid(row = 7, column = 3,padx=25 )          def CancelPenalty(self):        self.ldWin.withdraw()        self.homeWin.deiconify()                    def reportHome(self):        self.homeWin.withdraw()        self.reportHomeWindow = Tk()        win = self.reportHomeWindow        Button(win, text = 'Damaged Books Report', command = self.damagedBooksReport).pack()        Button(win, text = 'Popular Books Report', command = self.popularBooksReport).pack()        Button(win, text = 'Frequent Users Report', command = self.frequentUserReport).pack()        Button(win, text = 'Popular Subject Report', command = self.popularSubjectReport).pack()        Button(win, text = 'Return to Homepage', command = self.reportToHome).pack()    def reportToHome(self):        self.reportHomeWindow.withdraw()        self.homeWin.deiconify()                    def damagedBooksReport(self):        dbrWin=Toplevel()        self.dbrWin = dbrWin        dbrWin.title("Damaged Book Report")                Label(dbrWin,text = 'Month').grid(row=0,column=0,sticky=W)        Label(dbrWin,text='Subject').grid(row=0,column=3,sticky=E)        Label(dbrWin,text='Subject').grid(row=1,column=3,sticky=E)        Label(dbrWin,text='Subject').grid(row=2,column=3,sticky=E)        getSubjectSQL = "SELECT Sub_name FROM SUBJECT"        self.c.execute(getSubjectSQL)        helper = self.c.fetchall()        subjectList =[]        for item in helper:            subjectList.append(item[0])        self.db.commit()                bar1 = Scrollbar(dbrWin)        bar1.grid(row = 0, column = 1, sticky = E)        self.listA = Listbox(dbrWin, yscrollcommand = bar1.set, height = 2,exportselection = 0,selectmode = SINGLE)        self.listA.insert(END, 'Jan')        self.listA.insert(END, 'Feb')        self.listA.insert(END, 'Mar')        self.listA.grid(row = 0, column= 2)        bar1.config(command = self.listA.yview)                bar2 = Scrollbar(dbrWin)        bar2.grid(row = 0, column = 4, sticky = E)        self.listB = Listbox(dbrWin, yscrollcommand = bar2.set, height = 2,exportselection = 0,selectmode = SINGLE)        for item in subjectList:            self.listB.insert(END, item)        self.listB.grid(row = 0, column= 5)        bar2.config(command = self.listB.yview)        bar3 = Scrollbar(dbrWin)        bar3.grid(row = 1, column = 4, sticky = E)        self.listC = Listbox(dbrWin, yscrollcommand = bar3.set, height = 2,exportselection = 0,selectmode = SINGLE)        for item in subjectList:            self.listC.insert(END, item)        self.listC.grid(row = 1, column= 5)        bar3.config(command = self.listC.yview)                bar4 = Scrollbar(dbrWin)        bar4.grid(row = 2, column = 4, sticky = E)        self.listD = Listbox(dbrWin, yscrollcommand = bar4.set, height = 2,exportselection = 0,selectmode = SINGLE)        for item in subjectList:            self.listD.insert(END, item)        self.listD.grid(row = 2, column= 5)        bar4.config(command = self.listD.yview)        Button(dbrWin, text = 'Subject', command = lambda:self.showdbr()).grid(row = 3, column = 3)        self.dbrWin = dbrWin        pass        def showdbr(self):        try:            mon = self.listA.get(self.listA.curselection()[0])            s1 = self.listB.get(self.listB.curselection()[0])            s2 = self.listC.get(self.listC.curselection()[0])            s3 = self.listD.get(self.listD.curselection()[0])            self.showdbrReport(mon,s1,s2,s3)        except:            messagebox.askokcancel("","You need to select some values")            return                def showdbrReport(self, mon, s1,s2,s3):        getDamageSQL = "SELECT ISBN, Copy_Number FROM BOOK_COPY WHERE Is_damaged = 1"        self.c.execute(getDamageSQL)                helper = self.c.fetchall()        damageList =[]        for item in helper:            getIssueID = 'SELECT Issue_ID FROM ISSUE WHERE ISBN = %s AND Copy_Number = %s'            self.c.execute(getIssueID,(str(item[0]),int(item[1])))            helper2 = self.c.fetchall()            IDs = []            try:                for i in helper2:                    IDs.append(i[0])                getMonthSQL = 'SELECT MONTH(Return_Date) FROM ISSUE WHERE ISBN = %s AND Copy_Number = %s AND Issue_ID = %s'                self.c.execute(getMonthSQL,(str(item[0]),int(item[1]),int(max(IDs))))                aMonth = self.c.fetchall()[0][0]                if aMonth == 1:                     damageList.append((item[0],item[1],'Jan'))                elif aMonth == 2:                     damageList.append((item[0],item[1],'Feb'))                elif aMonth == 3:                     damageList.append((item[0],item[1],'Mar'))            except:                pass        self.db.commit()        countS1 = 0        countS2 = 0        countS3 = 0        for item in damageList:            getAsubject = 'SELECT Sub_name FROM BOOK WHERE ISBN = %s'            self.c.execute(getAsubject,item[0])            aSubject = self.c.fetchall()[0][0]            if aSubject == s1 and item[2] == mon:                countS1 = countS1 + 1            elif aSubject == s2 and item[2] == mon:                countS2 = countS2 + 1            elif aSubject == s3 and item[2] == mon:                countS3 = countS3 + 1               table = Frame(self.dbrWin)                        table.grid(row = 4, column = 0,columnspan = 6,sticky = W + E + N)        monthColumn = Frame(table,relief = RIDGE,bd = 2)        monthColumn.grid(row = 0, column = 0, sticky = W + N + S + E,ipadx = 40)        Label(monthColumn, text = 'Month').grid(row = 0)        Label(monthColumn, text = mon).grid(row = 2)        subjectColumn = Frame(table,relief = RIDGE,bd = 2)        subjectColumn.grid(row = 0, column = 1, sticky = W + N + S + E,ipadx = 40)        Label(subjectColumn, text = 'Subject').grid(row = 0)        Label(subjectColumn, text = s1).grid(row = 1)        numberColumn = Frame(table,relief = RIDGE,bd = 2)        numberColumn.grid(row = 0, column = 2, sticky = W + N + S + E,ipadx = 40)        Label(numberColumn, text = '#damaged books').grid(row = 0)        Label(numberColumn, text = str(countS1)).grid(row = 1)        if s1 != s2:            Label(subjectColumn, text = s2).grid(row = 2)            Label(numberColumn, text = str(countS2)).grid(row = 2)        else:            Label(subjectColumn, text = '').grid(row = 2)            Label(numberColumn, text = '').grid(row = 2)        if s3 != s1 and s3 != s2:            Label(subjectColumn, text = s3).grid(row = 3)            Label(numberColumn, text = str(countS3)).grid(row = 3)        else:            Label(subjectColumn, text = '').grid(row = 3)            Label(numberColumn, text = '').grid(row = 3)    def popularBooksReport(self):        pbrWin = Toplevel()        pbrWin.title('Popular Books Report')        monthFrame = Frame(pbrWin,relief = RIDGE,bd = 2)        monthFrame.grid(row = 0, column = 1, ipadx = 30)        Label(monthFrame, text ='Month').grid(row = 0)        Label(monthFrame, text = 'Jan').grid(row = 1)        Label(monthFrame, text = '').grid(row = 2)        Label(monthFrame, text = '').grid(row = 3)        Label(monthFrame, text = 'Feb').grid(row = 4)        Label(monthFrame, text = '').grid(row = 5)        Label(monthFrame, text = '').grid(row = 6)                titleFrame = Frame(pbrWin,relief = RIDGE,bd = 2)        titleFrame.grid(row = 0, column = 2, ipadx = 30,sticky = N)        Label(titleFrame, text = 'Title').grid(row = 0,sticky = N)                checkoutFrame = Frame(pbrWin,relief = RIDGE,bd = 2)        checkoutFrame.grid(row = 0, column = 3, ipadx = 30,sticky = N)        Label(checkoutFrame, text = '#checkouts').grid(row = 0,sticky = N)        sql1 = 'SELECT COUNT(ISSUE_ID),ISBN FROM ISSUE WHERE MONTH(Date_of_issue)= 1 GROUP BY ISBN ORDER BY COUNT(ISSUE_ID) DESC'        sql2 = 'SELECT COUNT(ISSUE_ID),ISBN FROM ISSUE WHERE MONTH(Date_of_issue)= 2 GROUP BY ISBN ORDER BY COUNT(ISSUE_ID) DESC'        JanBooks = []        JanNums = []        FebBooks = []        FebNums = []        self.c.execute(sql1)        helper1 = self.c.fetchall()        self.c.execute(sql2)        helper2 = self.c.fetchall()        for item in helper1:            sql3 = 'SELECT Title FROM BOOK WHERE ISBN = %s'            self.c.execute(sql3, item[1])            title = self.c.fetchall()[0]            JanBooks.append(title)            JanNums.append(item[0])        for item in helper2:            sql4 = 'SELECT Title FROM BOOK WHERE ISBN = %s'            self.c.execute(sql4, item[1])            title = self.c.fetchall()[0]            FebBooks.append(title)            FebNums.append(item[0])        for i in range(3):            try:               Label(titleFrame, text = JanBooks[i][0]).grid(row = 1 + i)            except:               Label(titleFrame, text = "").grid(row = 1 + i)         for i in range(3):            try:               Label(titleFrame, text = FebBooks[i][0]).grid(row = 4 + i)            except:               Label(titleFrame, text = "").grid(row = 4 + i)        for i in range(3):            try:               Label(checkoutFrame, text = JanNums[i]).grid(row = 1 + i)            except:               Label(checkoutFrame, text = "").grid(row = 1 + i)        for i in range(3):            try:               Label(checkoutFrame, text = FebNums[i]).grid(row = 4 + i)            except:               Label(checkoutFrame, text = "").grid(row = 4 + i)             def frequentUserReport(self):        furWin = Toplevel()        furWin.title('Frequent Users Report')        monthFrame = Frame(furWin,relief = RIDGE,bd = 2)        monthFrame.grid(row = 0, column = 1, ipadx = 30)        Label(monthFrame, text ='Month').grid(row = 0)        nameFrame = Frame(furWin,relief = RIDGE,bd = 2)        nameFrame.grid(row = 0, column = 2, ipadx = 30,sticky = N)        Label(nameFrame, text = 'User Name').grid(row = 0,sticky = N)                checkoutFrame = Frame(furWin,relief = RIDGE,bd = 2)        checkoutFrame.grid(row = 0, column = 3, ipadx = 30,sticky = N)        Label(checkoutFrame, text = '#checkouts').grid(row = 0,sticky = N)        sql1 = 'SELECT COUNT(ISSUE_ID),Username FROM ISSUE WHERE MONTH(Date_of_issue)= 1 GROUP BY Username ORDER BY COUNT(ISSUE_ID) DESC'        sql2 = 'SELECT COUNT(ISSUE_ID),Username FROM ISSUE WHERE MONTH(Date_of_issue)= 2 GROUP BY Username ORDER BY COUNT(ISSUE_ID) DESC'        self.c.execute(sql1)        helper1 = self.c.fetchall()        #print(helper1)        self.c.execute(sql2)        helper2 = self.c.fetchall()        #print(helper2)        JanPeople = []        JanTimes = []        FebPeople = []        FebTimes = []        j = 1        for i in range(5):            try:                if helper1[i][0] > 10:                #change to 10 later                    Label(monthFrame,text ='').grid(row = 1 +i)                    Label(monthFrame, text = 'Jan').grid(row = 1)                    Label(nameFrame,text = helper1[i][1]).grid(row = i+1)                    Label(checkoutFrame,text = helper1[i][0]).grid(row = i + 1)                    j = j + 1            except:                break        for i in range(5):            try:                if helper2[i][0] > 10:                 #change to 10 later                    Label(monthFrame,text ='').grid(row = j+i)                    Label(monthFrame, text = 'Feb').grid(row = j)                    Label(nameFrame,text = helper2[i][1]).grid(row = j+i)                    Label(checkoutFrame,text = helper2[i][0]).grid(row = j + i)            except:                pass    def popularSubjectReport(self):        psWin = Toplevel()        psWin.title('Popular Subject Report')        monthFrame = Frame(psWin,relief = RIDGE,bd = 2)        monthFrame.grid(row = 0, column = 1, ipadx = 30)        Label(monthFrame, text ='Month').grid(row = 0,sticky = N)        Label(monthFrame, text ='Jan').grid(row = 1,sticky = N)        Label(monthFrame, text ='').grid(row = 2,sticky = N)        Label(monthFrame, text ='').grid(row = 3,sticky = N)        Label(monthFrame, text ='Feb').grid(row = 4,sticky = N)        Label(monthFrame, text ='').grid(row = 5,sticky = N)        Label(monthFrame, text ='').grid(row = 6,sticky = N)        subFrame = Frame(psWin,relief = RIDGE,bd = 2)        subFrame.grid(row = 0, column = 2, ipadx = 30,sticky = N)        Label(subFrame, text = 'Top Subject').grid(row = 0,sticky = N)                checkoutFrame = Frame(psWin,relief = RIDGE,bd = 2)        checkoutFrame.grid(row = 0, column = 3, ipadx = 30,sticky = N)        Label(checkoutFrame, text = '#checkouts').grid(row = 0,sticky = N)        sql1 = 'SELECT COUNT(ISSUE_ID),ISBN FROM ISSUE WHERE MONTH(Date_of_issue)= 1 GROUP BY ISBN ORDER BY COUNT(ISSUE_ID) DESC'        sql2 = 'SELECT COUNT(ISSUE_ID),ISBN FROM ISSUE WHERE MONTH(Date_of_issue)= 2 GROUP BY ISBN ORDER BY COUNT(ISSUE_ID) DESC'        self.c.execute(sql1)        helper1 = self.c.fetchall()        self.c.execute(sql2)        helper2 = self.c.fetchall()        sList1 = []        sList2 = []        for item in helper1:            sql3 = "SELECT Sub_name FROM BOOK WHERE ISBN = %s"            self.c.execute(sql3, item[1])            subject = self.c.fetchall()[0][0]            if len(sList1) != 0:                k = 0                for k in range(len(sList1)):                                         if sList1[k][1] == subject:                         sList1[k][0] = int(sList1[k][0]) + int(item[0])                         break                     elif k == len(sList1) - 1:                         sList1.append([item[0],subject])                            else:                sList1.append([item[0],subject])        for item in helper2:            sql3 = "SELECT Sub_name FROM BOOK WHERE ISBN = %s"            self.c.execute(sql3, item[1])            subject = self.c.fetchall()[0][0]            if len(sList2) != 0:                k = 0                for k in range(len(sList2)):                                         if sList2[k][1] == subject:                         sList2[k][0] = int(sList2[k][0]) + int(item[0])                         break                     elif k == len(sList2) - 1:                         sList2.append([item[0],subject])                            else:                sList2.append([item[0],subject])        sList1.sort(reverse = True)        sList2.sort(reverse = True)        for i in range(3):            try:               Label(subFrame, text = sList1[i][1]).grid(row = 1 + i)            except:               Label(subFrame, text = "").grid(row = 1 + i)         for i in range(3):            try:               Label(checkoutFrame, text = sList1[i][0]).grid(row = 1 + i)            except:               Label(checkoutFrame, text = "").grid(row = 1 + i)        for i in range(3):            try:               Label(subFrame, text = sList2[i][1]).grid(row = 4 + i)            except:               Label(subFrame, text = "").grid(row = 4 + i)        for i in range(3):            try:               Label(checkoutFrame, text = sList2[i][0]).grid(row = 4 + i)            except:               Label(checkoutFrame, text = "").grid(row = 4 + i)             obj = LMS()